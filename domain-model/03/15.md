SQL 标准定义了三种日期时间类型：
- DATE - 对应 java.sql.Date, 有 year, month, day
- TIME - 对应 java.sql.Time, 有 hour, minute, second
- TIMESTAMP - 对应 java.sql.Timestamp, 有 year, month, day, hour, minute, second, 以及 nanoseconds


通常使用 java.util/java.time 下的类，而不是 java.sql 下的类，避免依赖 java.sql 包


java.sql 包中的类定义了直接对应的 SQL type ，因此 java.util 类型的属性就需要显式(使用 @Temporal)指定 SQL type 。


如果使用 java.util.Calendar 还会考虑时区。


java.time 下的类型与 SQL 类型的对应关系：
- DATE - java.time.LocalDate
- TIME - java.time.LocalTime, java.time.OffsetTime
- TIMESTAMP - java.time.Instant, java.time.LocalDateTime, java.time.OffsetDateTime and java.time.ZonedDateTime


如果对 java.time 类型加 @Temporal 则将抛异常 org.hibernate.AnnotationException: @Temporal should only be set on a java.util.Date or java.util.Calendar property


当保存 java.sql.Timestamp or a java.sql.Time 类型属性时， Hibernate 会调用
- PreparedStatement.setTimestamp(int parameterIndex, java.sql.Timestamp)
- PreparedStatement.setTime(int parameterIndex, java.sql.Time x)


如果没有指定 time zone 则 JDBC driver 会使用 JVM 的默认时区，但这通常不正确。


通常使用一个 single reference time zone (e.g. UTC) 来读写数据库。 Hibernate 提供 hibernate.jdbc.time_zone 配置属性。


hibernate.jdbc.time_zone 可以通过 settings.put(AvailableSettings.JDBC_TIME_ZONE, TimeZone.getTimeZone("UTC")); 在 SessionFactory 范围配置，也可以通过 Session session = sessionFactory().withOptions().jdbcTimeZone(TimeZone.getTimeZone("UTC")).openSession(); 在 Session 范围配置。


如果有配置 hibernate.jdbc.time_zone 则 Hibernate 会调用
- PreparedStatement.setTimestamp(int parameterIndex, java.sql.Timestamp, Calendar cal)
- PreparedStatement.setTime(int parameterIndex, java.sql.Time x, Calendar cal)
其中 cal 参数用于指定 time zone

